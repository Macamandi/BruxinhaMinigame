#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <avr/pgmspace.h> // Biblioteca para usar PROGMEM

// --- Configurações da Tela ---
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET    -1
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);
// --- Pinos de Controle ---
#define UP_BUTTON     5
#define DOWN_BUTTON   4
#define LEFT_BUTTON   3
#define RIGHT_BUTTON  2
#define BUZZER 6

//--- Definições do Atlas de Sprites ---
#define SPRITESHEET_WIDTH 240
#define WITCH_WIDTH   48
#define WITCH_HEIGHT  48
#define BAT_WIDTH     16
#define BAT_HEIGHT    48
#define ICON_WIDTH    16
#define ICON_HEIGHT   16

#define SPRITE_A_X 0    // Game Over 48x48
#define SPRITE_B_X 48   // Neutra 48x48
#define SPRITE_C_X 96   // Ataque 48x48
#define SPRITE_D_X 144  // Dano 48x48
#define SPRITE_E_X 192  // Morcego frame 1 16x48
#define SPRITE_F_X 208  // Morcego frame 2 16x48
#define ICON_STACK_X 224
#define SPRITE_G_Y 0    // Chapéu (vida)
#define SPRITE_H_Y 16   // Bombom (power-up)
#define SPRITE_I_Y 32   // Estrelinha (ataque)

// Matriz de Sprites
const unsigned char PROGMEM spritesheet[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 
	0x80, 0x00, 0x00, 0x3f, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 0x00, 0x40, 0x00, 
	0x00, 0x40, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x40, 0x00, 0x00, 0x01, 0x00, 0x00, 0x40, 0x00, 0x00, 0x40, 
	0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x01, 0x06, 0x0c, 0x40, 0x00, 0x00, 0x01, 0x00, 0x00, 0x20, 0x00, 0x00, 0x80, 0x00, 0x10, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 
	0x01, 0x10, 0x20, 0x00, 0x00, 0x01, 0x06, 0x06, 0x20, 0x00, 0x00, 0x81, 0x20, 0x10, 0x40, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0xa0, 
	0x20, 0x00, 0x00, 0x02, 0x01, 0x08, 0x20, 0x10, 0x00, 0x8e, 0x10, 0x08, 0xa0, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x08, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x0f, 0x1e, 0x20, 0x00, 
	0x00, 0x04, 0x0e, 0x90, 0x20, 0x28, 0x00, 0x80, 0x0e, 0x05, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x04, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x98, 0xf1, 0x20, 0x00, 0x00, 0x08, 
	0x9f, 0x6e, 0x20, 0x54, 0x00, 0x8f, 0xff, 0x22, 0x4a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0xc9, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x97, 0x6e, 0xa0, 0x00, 0x00, 0xfb, 0x99, 0xf9, 
	0x20, 0xd6, 0x00, 0x83, 0xf3, 0x39, 0xf5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x42, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x96, 0x6c, 0xa0, 0x00, 0x03, 0x00, 0x96, 0xf6, 0xa1, 0x39, 
	0x00, 0x8d, 0xef, 0x20, 0xe9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0xcc, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x08, 0x97, 0x6e, 0xa0, 0x00, 0x04, 0x00, 0x97, 0x6e, 0xa2, 0xfe, 0x00, 0x8e, 
	0xdf, 0x20, 0xa1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x08, 0x30, 0x9f, 0xfe, 0x20, 0x00, 0x08, 0x00, 0x9f, 0xfe, 0x21, 0x7d, 0x00, 0x8f, 0xff, 0x20, 
	0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2f, 0xf4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0xc0, 
	0x8f, 0xde, 0x20, 0x00, 0x10, 0x00, 0x8f, 0x1e, 0x20, 0xaa, 0x00, 0x8f, 0x1e, 0x20, 0x44, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x54, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x87, 0xfc, 
	0x30, 0x00, 0x13, 0x00, 0x86, 0xec, 0x21, 0x55, 0x00, 0xc6, 0xec, 0x20, 0x58, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0xa8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x03, 0x18, 0x68, 0x00, 
	0x14, 0xc0, 0x02, 0xe8, 0x41, 0x29, 0x00, 0x62, 0x08, 0x00, 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0xd0, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x41, 0xf0, 0xd4, 0x00, 0x18, 0x30, 
	0x40, 0xe0, 0x80, 0xc6, 0x03, 0xf1, 0xf0, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0xfa, 0x0f, 0x92, 0x00, 0x00, 0x08, 0xfa, 0xef, 
	0x00, 0x00, 0x04, 0x1e, 0x08, 0x01, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x07, 0xf3, 0x7d, 0x00, 0x00, 0x07, 0xc7, 0x12, 0x00, 0x00, 
	0x0b, 0xed, 0x7d, 0xf5, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xfe, 0xa7, 0xfd, 0xba, 0x00, 0x00, 0x00, 0xa7, 0xfd, 0x02, 0x00, 0x0b, 0xea, 
	0x7f, 0x1b, 0x68, 0x00, 0x40, 0x02, 0x04, 0x20, 0x00, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0d, 0x40, 0x71, 0xaa, 0x00, 0x00, 0x01, 0x50, 0x70, 0x82, 0x00, 0x0b, 0xe5, 0x06, 0x6d, 
	0x08, 0x00, 0xa4, 0x25, 0x0b, 0xd0, 0x03, 0xc1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 
	0xa3, 0x26, 0xd4, 0x00, 0x00, 0x02, 0xa3, 0x26, 0x8f, 0x80, 0x0b, 0xea, 0x30, 0x13, 0x68, 0x00, 
	0xab, 0xd5, 0x04, 0x20, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x40, 0x81, 
	0x54, 0x00, 0x00, 0x3d, 0x50, 0x81, 0x42, 0x00, 0x0b, 0xe5, 0x08, 0x04, 0x08, 0x00, 0xa4, 0x25, 
	0x0a, 0x50, 0x0b, 0xe1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x80, 0x00, 0x54, 0x00, 
	0x00, 0x41, 0x80, 0x00, 0x42, 0x00, 0x04, 0x08, 0x00, 0x07, 0x50, 0x00, 0x9a, 0x59, 0x3a, 0x5c, 
	0x15, 0xaf, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x10, 0x00, 0x54, 0x00, 0x00, 0xbe, 
	0x00, 0x00, 0x20, 0x00, 0x03, 0xe0, 0x01, 0x09, 0x50, 0x00, 0x82, 0x41, 0x40, 0x02, 0x14, 0x28, 
	0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x98, 0x00, 0x82, 0x00, 0x00, 0xbe, 0x98, 0x00, 
	0xa0, 0x00, 0x00, 0x1f, 0x42, 0x10, 0xa0, 0x00, 0x80, 0x01, 0x80, 0x01, 0x14, 0x28, 0x54, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x0c, 0x21, 0x5a, 0x00, 0x00, 0xbe, 0x5c, 0x21, 0x50, 0x00, 
	0x00, 0x01, 0x67, 0x60, 0x40, 0x00, 0x80, 0x01, 0x80, 0x01, 0xf6, 0x68, 0x92, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x09, 0xef, 0xf4, 0xc2, 0x00, 0x00, 0xbe, 0xaf, 0xf2, 0x90, 0x00, 0x00, 0x00, 
	0xbf, 0x40, 0x00, 0x00, 0x40, 0x02, 0x80, 0x01, 0x87, 0xd0, 0x7d, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0b, 0xef, 0xd2, 0xda, 0x00, 0x00, 0xbe, 0xaf, 0xd5, 0x48, 0x00, 0x00, 0x00, 0xbf, 0x40, 
	0x00, 0x00, 0x30, 0x0c, 0xb8, 0x1d, 0x80, 0x20, 0xba, 0x3f, 0xff, 0x80, 0x00, 0x00, 0x00, 0x0b, 
	0xef, 0xd5, 0xc2, 0x00, 0x00, 0x41, 0xaf, 0xd4, 0xa8, 0x08, 0x00, 0x00, 0x5e, 0x40, 0x00, 0x00, 
	0x08, 0x10, 0xa4, 0x25, 0x83, 0xc0, 0xaa, 0x40, 0x00, 0x41, 0x00, 0x00, 0x00, 0x0b, 0xe7, 0xf2, 
	0xda, 0x00, 0x00, 0x3e, 0xa7, 0xf6, 0xf4, 0x34, 0x00, 0x00, 0x8f, 0x40, 0x00, 0x00, 0x04, 0x20, 
	0xa2, 0x45, 0x82, 0xab, 0x54, 0x80, 0x00, 0x32, 0x80, 0x00, 0x00, 0x0b, 0xe8, 0x0c, 0x02, 0x00, 
	0x00, 0x01, 0x58, 0x0a, 0xfb, 0xca, 0x00, 0x01, 0x60, 0x40, 0x00, 0x00, 0x02, 0x40, 0x42, 0x42, 
	0xa2, 0xab, 0x54, 0x80, 0x00, 0x0c, 0xfe, 0x00, 0x00, 0x04, 0x0c, 0x0d, 0xd4, 0x00, 0x00, 0x00, 
	0xbc, 0x0c, 0x00, 0x39, 0x00, 0x02, 0xf0, 0x40, 0x00, 0x00, 0x02, 0x40, 0x01, 0x80, 0xaa, 0xab, 
	0x55, 0x00, 0x00, 0x00, 0xc1, 0x00, 0x00, 0x03, 0x7e, 0x1d, 0x54, 0x00, 0x00, 0x01, 0x7e, 0x1c, 
	0xab, 0xde, 0x00, 0x05, 0xf8, 0xc0, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x00, 0x55, 0x01, 
	0x40, 0x01, 0x86, 0x80, 0x00, 0x01, 0x7e, 0x1d, 0x28, 0x00, 0x00, 0x01, 0x7e, 0x1c, 0xa8, 0x39, 
	0x00, 0x05, 0xf9, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x0e, 0x38, 0x03, 
	0x4f, 0x40, 0x00, 0x01, 0x7e, 0x3d, 0x10, 0x00, 0x00, 0x01, 0x7e, 0x3c, 0x03, 0xca, 0x00, 0x05, 
	0xfb, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x80, 0x55, 0x00, 0x00, 0x0e, 0xef, 0xa0, 
	0x00, 0x00, 0xbe, 0xbd, 0x00, 0x00, 0x00, 0x01, 0x7d, 0xbd, 0xfc, 0x34, 0x00, 0x02, 0xfb, 0xa0, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x40, 0x55, 0x3f, 0xfe, 0x41, 0xef, 0xa0, 0x00, 0x00, 
	0xbe, 0xbd, 0x00, 0x00, 0x00, 0x01, 0x7d, 0xbd, 0x00, 0x08, 0x00, 0xff, 0x53, 0xa0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x7c, 0xbe, 0x57, 0x55, 0xae, 0x67, 0xdf, 0xa0, 0x00, 0x00, 0xaa, 0xa9, 
	0x00, 0x00, 0x00, 0x01, 0x55, 0xa9, 0x00, 0x00, 0x01, 0x00, 0x29, 0x20, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x82, 0x81, 0x83, 0x5b, 0xde, 0x4f, 0xdf, 0x5f, 0x00, 0x00, 0x54, 0x95, 0x00, 0x00, 
	0x00, 0x00, 0xa9, 0x95, 0x00, 0x00, 0x01, 0x7a, 0x52, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x8a, 0xa9, 0xb5, 0x55, 0xae, 0x47, 0xca, 0xf0, 0x00, 0x00, 0x4a, 0xa9, 0x00, 0x00, 0x00, 0x00, 
	0x95, 0xa9, 0x00, 0x00, 0x01, 0x20, 0xa5, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0xa6, 
	0x86, 0x1f, 0xfe, 0x43, 0xd4, 0x1e, 0x00, 0x00, 0x41, 0xc1, 0x00, 0x00, 0x00, 0x00, 0x83, 0xc1, 
	0x00, 0x00, 0x01, 0x20, 0x54, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0xa2, 0xb6, 0x18, 
	0x1c, 0x00, 0xca, 0x44, 0x00, 0x00, 0x51, 0xd1, 0x00, 0x00, 0x00, 0x00, 0xa3, 0xd1, 0x00, 0x00, 
	0x01, 0x20, 0xad, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0xa9, 0x87, 0x0d, 0xb8, 0x0f, 
	0x25, 0x04, 0x00, 0x00, 0x41, 0xc1, 0x00, 0x00, 0x00, 0x00, 0x83, 0xc1, 0x00, 0x00, 0x01, 0x1f, 
	0xfc, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x81, 0xb7, 0x85, 0xb0, 0x15, 0x2a, 0x04, 
	0x00, 0x00, 0x51, 0xd1, 0x00, 0x00, 0x00, 0x00, 0xa3, 0xd1, 0x00, 0x00, 0x01, 0x3f, 0xfd, 0x10, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xbe, 0x80, 0x02, 0x60, 0x95, 0x35, 0x1a, 0x00, 0x00, 
	0x51, 0xd1, 0x00, 0x00, 0x00, 0x00, 0xa3, 0xd1, 0x00, 0x00, 0x01, 0x7f, 0xfd, 0x18, 0x00, 0x00, 
	0xd5, 0x55, 0xd5, 0x55, 0x02, 0x40, 0x7f, 0xfc, 0x1f, 0x80, 0xfa, 0xec, 0x00, 0x1a, 0x9d, 0x5c, 
	0xac, 0x00, 0x00, 0x6a, 0xbd, 0x5c, 0xaa, 0xab, 0x06, 0xaa, 0xa9, 0xcd, 0x56, 0x00, 0x55, 0x54, 
	0x55, 0x54, 0x01, 0x80, 0xaa, 0xab, 0xea, 0xff, 0xaf, 0xaa, 0x00, 0x2a, 0xa1, 0x40, 0xaa, 0x00, 
	0x00, 0xaa, 0xa1, 0x40, 0xaa, 0xaa, 0x0a, 0xaa, 0xa8, 0x05, 0x55, 0x00, 0x55, 0x54, 0x55, 0x54, 
	0x00, 0x00, 0x6a, 0xaa, 0xaa, 0xaa, 0xaa, 0xab, 0x00, 0x1a, 0x81, 0x40, 0xac, 0x00, 0x00, 0x6a, 
	0x81, 0x40, 0xaa, 0xab, 0x06, 0xaa, 0xa8, 0x01, 0x56, 0x00, 0xd5, 0x55, 0xd5, 0x55, 0x00, 0x00
};
// --- Estruturas e Estados de Jogo ---
enum BatState { INACTIVE, ACTIVE, DEFEATED };
#define MAX_BATS 3 
struct Bat {
  int16_t x, y;
  BatState state;
  bool movingRight;
  uint8_t currentFrame;
  unsigned long defeatedEndTime;
};
struct Witch {
  int16_t x, y;
  bool isFlipped;
  int lives;
  unsigned long attackEndTime;
  unsigned long damageEndTime;
  bool attackButtonReleased;
};
struct PowerUp {
  int16_t x, y;
  bool active;
  bool movingRight;
};

// --- Variáveis Globais ---
Bat bats[MAX_BATS];
Witch player;
PowerUp bombom;
unsigned int score = 0;
unsigned int highscore = 0;
int batSpeed = 2;
unsigned long nextBatSpawnTime = 0;
unsigned long batSpawnInterval = 3000; 
unsigned long lastBatUpdateTime = 0;
unsigned long batMoveInterval = 80;
unsigned long lastBatAnimTime = 0;
#define BAT_ANIM_INTERVAL 200
#define BOMBOM_SPEED 2
unsigned long nextBombomSpawnTime = 0;
#define BOMBOM_SPAWN_INTERVAL 15000

// --- Variáveis de Jogo e Controle ---
bool needsRedraw = true;
#define ATTACK_DURATION 250
#define DAMAGE_DURATION 1000
#define GAMEOVER_DURATION 1000
#define ATTACK_RANGE 5
#define DEFEATED_DURATION 500 
int attackRangeBonus = 0;
bool isGameOver = false;
unsigned long lastButtonPressTime = 0;
#define DEBOUNCE_DELAY 200

// --- Declaração das funções ---
void spawnBat(); void updateBats(); void drawBats();
void spawnBombom();
void updateBombom(); void drawBombom();
void updateGameLogic(); void updateBatAnimation();
void clearAllBats(); void resetGame(); 
void handleInput(); 
void handleSerialInput(); // <-- DECLARAÇÃO DA NOVA FUNÇÃO
void attack(); void drawHUD(); void drawScreen();
void drawSprite(int16_t x, int16_t y, int16_t spriteX, int16_t spriteY, int16_t w, int16_t h, bool flipped);
void enviarFrameParaPC();

void setup() {
  Serial.begin(500000); 
  randomSeed(analogRead(0));
  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("Falha ao iniciar SSD1306"));
    for(;;);
  }
  pinMode(UP_BUTTON, INPUT_PULLUP); 
  pinMode(DOWN_BUTTON, INPUT_PULLUP);
  pinMode(LEFT_BUTTON, INPUT_PULLUP);
  pinMode(RIGHT_BUTTON, INPUT_PULLUP);
  pinMode(BUZZER, OUTPUT);
  resetGame();
  display.clearDisplay(); 
  display.display();
}

void loop() {
  if (isGameOver) {
    if (millis() - player.damageEndTime > GAMEOVER_DURATION) {
			for(int i=0;i<3;i++){
				tone(BUZZER,600);
        delay(100); 
        noTone(BUZZER); 
        delay(50);
			}
      delay(1000); 
      noTone(BUZZER); 
      resetGame();
    }
  } else {
    handleInput();        // Lida com os botões físicos
    handleSerialInput();  // <-- CHAMADA DA NOVA FUNÇÃO (Lida com o controle do PC)
    updateGameLogic();
  }
  if (player.attackEndTime != 0 && millis() > player.attackEndTime) {
      player.attackEndTime = 0;
      needsRedraw = true;
  }
  if (needsRedraw) {
    drawScreen();
    enviarFrameParaPC(); // Envia o frame para o PC
    needsRedraw = false;
  }
}

// --- FUNÇÕES DE LÓGICA DO JOGO ---
void updateGameLogic() {
  if (millis() < player.damageEndTime) return;
  if (millis() >= nextBatSpawnTime) {
    spawnBat();
    if (batSpawnInterval > 1000) batSpawnInterval -= 50;
    nextBatSpawnTime = millis() + batSpawnInterval;
  }
  if (millis() >= nextBombomSpawnTime) {
    spawnBombom();
  }
  if (millis() - lastBatUpdateTime > batMoveInterval) {
    updateBats();
    updateBombom();
    lastBatUpdateTime = millis();
  }
  if (millis() - lastBatAnimTime > BAT_ANIM_INTERVAL) {
    updateBatAnimation(); 
    lastBatAnimTime = millis();
  }
}

void handleInput() {
  if (millis() - lastButtonPressTime < DEBOUNCE_DELAY) return;
  bool buttonPressed = false;
  if (digitalRead(LEFT_BUTTON) == HIGH && digitalRead(RIGHT_BUTTON) == HIGH) {
      player.attackButtonReleased = true;
  }
  if (digitalRead(UP_BUTTON) == LOW && player.y > 0) {
    player.y = 0; 
    buttonPressed = true;
  } else if (digitalRead(DOWN_BUTTON) == LOW && player.y < 16) {
    player.y = 16; 
    buttonPressed = true;
  } else if (digitalRead(LEFT_BUTTON) == LOW && player.attackEndTime == 0 && player.attackButtonReleased) {
    player.isFlipped = true; 
    attack();
    player.attackButtonReleased = false; 
    buttonPressed = true;
  } else if (digitalRead(RIGHT_BUTTON) == LOW && player.attackEndTime == 0 && player.attackButtonReleased) {
    player.isFlipped = false;
    attack(); 
    player.attackButtonReleased = false; 
    buttonPressed = true;
  }
  if (buttonPressed) {
    lastButtonPressTime = millis();
    needsRedraw = true;
  }
}

void attack() { 
  player.attackEndTime = millis() + ATTACK_DURATION;
}

void drawHUD() {
  for (int i = 0; i < player.lives; i++) {
    drawSprite(i * (ICON_WIDTH + 2), 0, ICON_STACK_X, SPRITE_G_Y, ICON_WIDTH, ICON_HEIGHT, false);
  }
  display.setTextSize(1); 
  display.setTextColor(SSD1306_WHITE);
  int scoreCursorX = SCREEN_WIDTH - (score < 10 ? 6 : (score < 100 ? 12 : (score < 1000 ? 18 : 24)));
  display.setCursor(scoreCursorX, 0); 
  display.print(score);
  int highscoreCursorX = SCREEN_WIDTH - (highscore < 10 ? 6 : (highscore < 100 ? 12 : (highscore < 1000 ? 18 : 24)));
  display.setCursor(highscoreCursorX, 8); 
  display.print(highscore);
}

void drawScreen() {
  display.clearDisplay();
  drawHUD();
  drawBats();
  drawBombom();
  int spriteSourceX;
  if (isGameOver) spriteSourceX = SPRITE_A_X;
  else if (millis() < player.damageEndTime) spriteSourceX = SPRITE_D_X;
  else if (player.attackEndTime != 0) spriteSourceX = SPRITE_C_X;
  else spriteSourceX = SPRITE_B_X;
  drawSprite(player.x, player.y, spriteSourceX, 0, WITCH_WIDTH, WITCH_HEIGHT, player.isFlipped);
  display.display();
}

void spawnBat() {
  for (int i = 0; i < MAX_BATS; i++) {
    if (bats[i].state == INACTIVE) {
      bats[i].state = ACTIVE;
      bats[i].currentFrame = random(2);
      if (random(2) == 0) { 
        bats[i].x = -BAT_WIDTH;
        bats[i].movingRight = true;
      } else { 
        bats[i].x = SCREEN_WIDTH; 
        bats[i].movingRight = false;
      }
      bats[i].y = (random(2) == 0) ? 0 : 16;
      return;
    }
  }
}

void spawnBombom() {
  if (!bombom.active) {
    bombom.active = true;
    if (random(2) == 0) { 
      bombom.x = -ICON_WIDTH; 
      bombom.movingRight = true;
    } else { 
      bombom.x = SCREEN_WIDTH; 
      bombom.movingRight = false;
    }
    bombom.y = (random(2) == 0) ? 32 : 48;
    nextBombomSpawnTime = millis() + BOMBOM_SPAWN_INTERVAL;
  }
}

void updateBombom() {
  if (!bombom.active) return;
  if (bombom.movingRight) bombom.x += BOMBOM_SPEED; else bombom.x -= BOMBOM_SPEED;
  needsRedraw = true;
  bool yOverlap = (player.y == 0 && bombom.y == 32) || (player.y == 16 && bombom.y == 48);
  bool xOverlap = (player.x < bombom.x + ICON_WIDTH && player.x + WITCH_WIDTH > bombom.x);
  if (yOverlap && xOverlap) {
    if (player.lives < 2) {
      player.lives++;
    } else {
      batSpeed++;
      attackRangeBonus += 5;
    }
    score++;
    tone(BUZZER, 1500, 100);
    bombom.active = false;
  }
  
  if (bombom.x < -ICON_WIDTH || bombom.x > SCREEN_WIDTH) {
    bombom.active = false;
  }
}

void updateBats() {
  for (int i = 0; i < MAX_BATS; i++) {
    if (bats[i].state == INACTIVE) continue;
    if (bats[i].state == DEFEATED) {
      if (millis() > bats[i].defeatedEndTime) { 
        bats[i].state = INACTIVE;
        needsRedraw = true; 
      }
      continue;
    }

    if (bats[i].movingRight) bats[i].x += batSpeed;
    else bats[i].x -= batSpeed;
    needsRedraw = true;

    if (player.attackEndTime != 0 && bats[i].state == ACTIVE) {
        bool yOverlap = (player.y == bats[i].y);
        if (!player.isFlipped && bats[i].x > player.x) {
            int distance = bats[i].x - (player.x + WITCH_WIDTH);
            if (yOverlap && distance >= 0 && distance < (ATTACK_RANGE + attackRangeBonus)) {
                score++;
                bats[i].state = DEFEATED;
                bats[i].defeatedEndTime = millis() + DEFEATED_DURATION;
                tone(BUZZER, 1200, 50); 
                continue;
            }
        } 
        else if (player.isFlipped && bats[i].x < player.x) {
            int distance = player.x - (bats[i].x + BAT_WIDTH);
            if (yOverlap && distance >= 0 && distance < (ATTACK_RANGE + attackRangeBonus)) {
                score++;
                bats[i].state = DEFEATED;
                bats[i].defeatedEndTime = millis() + DEFEATED_DURATION;
                tone(BUZZER, 1200, 50);
                continue;
            }
        }
    }

    if (millis() > player.damageEndTime) {
        bool yOverlap = (player.y == bats[i].y);
        bool xOverlap = (player.x < bats[i].x + BAT_WIDTH && player.x + WITCH_WIDTH > bats[i].x);
        if (xOverlap && yOverlap) {
          player.lives--;
          batSpeed = 2;
          attackRangeBonus = 0;
          tone(BUZZER,330,100); 
          tone(BUZZER,660,25);
          player.damageEndTime = millis() + DAMAGE_DURATION;
          clearAllBats();
          if (player.lives < 0) {
            if (score > highscore) highscore = score;
            isGameOver = true;
          }
          return;
        }
    }

    if (bats[i].x < -BAT_WIDTH || bats[i].x > SCREEN_WIDTH) {
      bats[i].state = INACTIVE;
    }
  }
}

void updateBatAnimation() {
  bool needsRedrawCheck = false;
  for (int i = 0; i < MAX_BATS; i++) {
    if (bats[i].state == ACTIVE) {
      bats[i].currentFrame = !bats[i].currentFrame;
      needsRedrawCheck = true;
    }
  }
  if(needsRedrawCheck) needsRedraw = true;
}

void drawBats() {
  for (int i = 0; i < MAX_BATS; i++) {
    if (bats[i].state == ACTIVE) {
      int16_t spriteToDrawX = (bats[i].currentFrame == 0) ?
      SPRITE_E_X : SPRITE_F_X;
      drawSprite(bats[i].x, bats[i].y, spriteToDrawX, 0, BAT_WIDTH, BAT_HEIGHT, false);
    } else if (bats[i].state == DEFEATED) {
      drawSprite(bats[i].x, bats[i].y, ICON_STACK_X, SPRITE_I_Y, ICON_WIDTH, ICON_HEIGHT, false);
    }
  }
}

void drawBombom() {
  if (bombom.active) {
    drawSprite(bombom.x, bombom.y, ICON_STACK_X, SPRITE_H_Y, ICON_WIDTH, ICON_HEIGHT, false);
  }
}

void clearAllBats() {
  for (int i = 0; i < MAX_BATS; i++) bats[i].state = INACTIVE;
}

void resetGame() {
  player.lives = 2; 
  player.x = 40; 
  player.y = 16;
  player.isFlipped = false; 
  player.attackEndTime = 0;
  player.damageEndTime = 0; 
  player.attackButtonReleased = true;
  score = 0; 
  isGameOver = false;
  batSpawnInterval = 3000;
  nextBatSpawnTime = millis() + batSpawnInterval;
  nextBombomSpawnTime = millis() + BOMBOM_SPAWN_INTERVAL;
  batSpeed = 2; 
  attackRangeBonus = 0;
  bombom.active = false;
  clearAllBats();
  needsRedraw = true;
}

void drawSprite(int16_t x, int16_t y, int16_t spriteX, int16_t spriteY, int16_t w, int16_t h, bool flipped) {
  int16_t spritesheetByteWidth = (SPRITESHEET_WIDTH + 7) / 8;
  for (int16_t j = 0; j < h; j++) {
    for (int16_t i = 0; i < w; i++) {
      int16_t sourceX = spriteX + i;
      int16_t sourceY = spriteY + j;
      uint8_t byte = pgm_read_byte(spritesheet + (sourceY * spritesheetByteWidth) + (sourceX / 8));
      if ((byte << (sourceX % 8)) & 0x80) {
        int16_t px = flipped ?
        x + w - 1 - i : x + i;
        display.drawPixel(px, y + j, SSD1306_WHITE);
      }
    }
  }
}

void enviarFrameParaPC() {
  Serial.write('S'); // Marcador de Início de Frame
  uint8_t *buffer = display.getBuffer();
  Serial.write(buffer, SCREEN_WIDTH * SCREEN_HEIGHT / 8);
  Serial.write('E'); // Marcador de Fim de Frame
}


// --- INÍCIO DAS NOVAS MODIFICAÇÕES ---

/**
 * @brief Lida com os comandos de controle recebidos pela porta serial do PC.
 * 'U' -> Cima, 'D' -> Baixo, 'L' -> Esquerda, 'R' -> Direita
 */
void handleSerialInput() {
  // Verifica se há algum dado disponível para ser lido na porta serial
  if (Serial.available() > 0) {
    // Lê o byte (caractere) de comando
    char comando = Serial.read();

    // Usa uma estrutura switch para executar a ação correspondente
    switch (comando) {
      case 'U': // Comando para CIMA
        if (player.y > 0) {
          player.y = 0;
          needsRedraw = true; // Sinaliza que a tela precisa ser redesenhada
        }
        break;
        
      case 'D': // Comando para BAIXO
        if (player.y < 16) {
          player.y = 16;
          needsRedraw = true;
        }
        break;
        
      case 'L': // Comando para ATAQUE À ESQUERDA
        // Apenas ataca se não estiver no meio de outro ataque
        if (player.attackEndTime == 0) {
          player.isFlipped = true; // Vira a bruxa para a esquerda
          attack();
          needsRedraw = true;
        }
        break;
        
      case 'R': // Comando para ATAQUE À DIREITA
        if (player.attackEndTime == 0) {
          player.isFlipped = false; // Vira a bruxa para a direita
          attack();
          needsRedraw = true;
        }
        break;
    }
  }
}